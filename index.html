<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Bunker Stalker - PC & Mobile</title>
    <style>
        * { box-sizing: border-box; touch-action: none; -webkit-user-select: none; user-select: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; position: fixed; font-family: 'Courier New', Courier, monospace; }
        #overlay { position: fixed; inset: 0; background: #000; color: white; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        #start-btn { padding: 20px 50px; font-size: 20px; background: #900; color: white; border: none; cursor: pointer; border-radius: 5px; font-weight: bold; }
        #game-container { width: 100%; height: 100%; position: relative; cursor: crosshair; }
        #death-screen, #win-screen { position: absolute; inset: 0; background: #000; z-index: 2000; display: none; flex-direction: column; align-items: center; justify-content: center; font-size: 24px; text-align: center; padding: 20px; font-weight: bold; letter-spacing: 4px; }
        #death-screen { color: #f00; }
        #win-screen { color: #0f0; }
        #ui-stats { position: absolute; top: 20px; width: 100%; text-align: center; color: #fff; z-index: 100; font-weight: bold; letter-spacing: 2px; text-shadow: 2px 2px #000; pointer-events: none; }
        #message-log { position: absolute; top: 20%; width: 100%; text-align: center; color: #0f0; z-index: 100; font-weight: bold; font-size: 18px; letter-spacing: 3px; pointer-events: none; opacity: 0; transition: opacity 0.5s; text-shadow: 0 0 10px #0f0; }
        #crosshair { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; z-index: 10; display: flex; align-items: center; justify-content: center; }
        #crosshair::before { content: ''; position: absolute; width: 2px; height: 100%; background: rgba(255,255,255,0.5); }
        #crosshair::after { content: ''; position: absolute; height: 2px; width: 100%; background: rgba(255,255,255,0.5); }
        
        /* UI HUD - Hidden by default on PC until touch is detected, or kept for reference */
        .mobile-ctrl { position: absolute; z-index: 150; }
        #joystick-container { bottom: 12%; left: 8%; width: 80px; height: 80px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; }
        #joystick-knob { position: absolute; top: 20px; left: 20px; width: 40px; height: 40px; background: #fff; border-radius: 50%; opacity: 0.7; }
        #ui-layer { bottom: 12%; right: 8%; display: flex; gap: 15px; }
        .btn { padding: 20px 25px; background: rgba(255,255,255,0.1); border: 2px solid #fff; color: white; border-radius: 8px; font-weight: bold; cursor: pointer; }
        
        #pc-hint { margin-top: 20px; font-size: 14px; opacity: 0.7; text-align: center; line-height: 1.6; }
    </style>
</head>
<body>

    <div id="overlay">
        <h2>VOID TRESPASS</h2>
        <p style="font-size: 12px; opacity: 0.6;">COLLECT 3 ARTIFACTS TO UNLOCK EXIT</p>
        <div id="pc-hint">
            PC: [WASD] Move | [MOUSE] Look | [L-CLICK] Fire | [F] Light<br>
            MOBILE: Virtual Controls
        </div>
        <button id="start-btn" style="margin-top:20px;">START SYSTEM</button>
    </div>

    <div id="game-container">
        <div id="ui-stats">ARTIFACTS: <span id="art-count">0</span>/3</div>
        <div id="message-log"></div>
        <div id="death-screen"><p>RECLAMATION COMPLETE</p></div>
        <div id="win-screen"><p>ESCAPED FROM THE THREAT</p></div>
        <div id="crosshair"></div>
        
        <div id="joystick-container" class="mobile-ctrl"><div id="joystick-knob"></div></div>
        <div id="ui-layer" class="mobile-ctrl">
            <div id="flashlight-toggle" class="btn">LIGHT</div>
            <div id="fire-btn" class="btn" style="border-color: #f00;">FIRE</div>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const _v1 = new THREE.Vector3(), _v2 = new THREE.Vector3(), _moveVec = new THREE.Vector3();
        const _playerBox = new THREE.Box3(), _entityBox = new THREE.Box3(), _wallBox = new THREE.Box3(), _exitBox = new THREE.Box3();
        const _pSize = new THREE.Vector3(0.6, 2.2, 0.6); 
        const _eSize = new THREE.Vector3(1.2, 3.5, 1.2); 

        let gameActive = false, scene, camera, renderer, player, entity, isLightOn = false, exitDoor;
        let leftHand, pistolGroup, leftLight, leftTip;
        let muzzleAnchor, muzzleLight, muzzleFlashMesh; 
        let collidableWalls = [], tubeMeshes = [], bobTimer = 0;
        let raycaster = new THREE.Raycaster();
        
        let recoilZ = 0, recoilRot = 0;
        let isJumpscaring = false, jumpscareTimer = 0;
        let isEntityDead = false, entityDeathTimer = 0;
        
        const bullets = [];
        let artifacts = [];
        let collectedCount = 0;
        
        // Input States
        const keys = { w: false, a: false, s: false, d: false };
        let mF = 0, mS = 0, lT = 0, lP = 0; // Movement and Look variables
        let jId = null, lId = null, lx, ly;

        const bulletGeo = new THREE.BoxGeometry(0.04, 0.04, 0.8);
        const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        function showMessage(text) {
            const log = document.getElementById('message-log');
            log.innerText = text;
            log.style.opacity = '1';
            setTimeout(() => { log.style.opacity = '0'; }, 4000);
        }

        function createGrimeTexture(color1, color2, isMossy = false) {
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d'); ctx.fillStyle = color1; ctx.fillRect(0,0,512,512);
            for(let i=0; i<15000; i++) {
                ctx.fillStyle = isMossy && Math.random() > 0.8 ? '#1a2e1a' : (Math.random() > 0.5 ? color2 : '#000000');
                ctx.globalAlpha = Math.random() * 0.25;
                ctx.fillRect(Math.random()*512, Math.random()*512, 4, 4);
            }
            return new THREE.CanvasTexture(canvas);
        }

        const wallTex = createGrimeTexture('#1a1a1a', '#2a221a'), floorTex = createGrimeTexture('#080808', '#1a1510'), ceilingTex = createGrimeTexture('#151515', '#0f1a0f', true);

        document.getElementById('start-btn').addEventListener('click', () => {
            document.getElementById('overlay').style.display = 'none';
            if(!window.gameInitialized) {
                init(); 
            } else {
                resetGame();
            }
            // Request Pointer Lock for PC
            if(window.innerWidth > 1024) {
                document.body.requestPointerLock();
            }
        });

        function init() {
            window.gameInitialized = true;
            scene = new THREE.Scene(); 
            scene.fog = new THREE.Fog(0x000000, 20, 80); 
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            document.getElementById('game-container').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.20));

            leftHand = new THREE.Group();
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.35, 12), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            body.rotation.x = Math.PI / 2;
            leftTip = new THREE.Mesh(new THREE.SphereGeometry(0.075, 12, 12), new THREE.MeshBasicMaterial({ color: 0x000000 }));
            leftTip.position.set(0, 0, -0.18);
            leftLight = new THREE.SpotLight(0xffffff, 0, 90, 1, 0.9, 1.2);
            const lt = new THREE.Object3D(); lt.position.set(0, 0, -15);
            leftHand.add(body, leftTip, leftLight, lt); leftLight.target = lt;
            camera.add(leftHand);

            pistolGroup = new THREE.Group();
            const slide = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.07, 0.3), new THREE.MeshStandardMaterial({ color: 0x181818 }));
            const grip = new THREE.Mesh(new THREE.BoxGeometry(0.045, 0.14, 0.06), new THREE.MeshStandardMaterial({ color: 0x0a0a0a }));
            grip.position.set(0, -0.09, 0.08); grip.rotation.x = 0.2;
            muzzleAnchor = new THREE.Group(); muzzleAnchor.position.set(0, 0.02, -0.2); 
            muzzleLight = new THREE.PointLight(0xffaa00, 0, 5);
            muzzleFlashMesh = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({ color: 0xffffaa, transparent: true, opacity: 0.8 }));
            muzzleFlashMesh.visible = false;
            muzzleAnchor.add(muzzleLight, muzzleFlashMesh);
            pistolGroup.add(slide, grip, muzzleAnchor);
            camera.add(pistolGroup);

            // Level Generation (Rooms)
            const R_SIZE = 45, D_GAP = 3.2, FULL_H = 12, DOOR_H = 4.5;
            const wallMat = new THREE.MeshStandardMaterial({ map: wallTex }), ceilingMat = new THREE.MeshStandardMaterial({ map: ceilingTex });

            function createRoom(cx, cz, n, s, e, w) {
                const buildWall = (tx, tz, trya) => {
                    const seg = (R_SIZE - D_GAP) / 2, off = (R_SIZE / 2) - (seg / 2);
                    const p1 = new THREE.Mesh(new THREE.BoxGeometry(seg, FULL_H, 1.5), wallMat);
                    p1.position.set(tx + (trya === 0 ? -off : 0), FULL_H/2, tz + (trya === 0 ? 0 : -off)); p1.rotation.y = trya;
                    const p2 = p1.clone(); p2.position.set(tx + (trya === 0 ? off : 0), FULL_H/2, tz + (trya === 0 ? 0 : off));
                    const top = new THREE.Mesh(new THREE.BoxGeometry(D_GAP, FULL_H - DOOR_H, 1.5), wallMat);
                    top.position.set(tx, DOOR_H + (FULL_H - DOOR_H)/2, tz); top.rotation.y = trya;
                    scene.add(p1, p2, top); collidableWalls.push(new THREE.Box3().setFromObject(p1), new THREE.Box3().setFromObject(p2), new THREE.Box3().setFromObject(top));
                };
                if (!n) { const m = new THREE.Mesh(new THREE.BoxGeometry(R_SIZE, FULL_H, 1.5), wallMat); m.position.set(cx, FULL_H/2, cz - R_SIZE/2); scene.add(m); collidableWalls.push(new THREE.Box3().setFromObject(m)); } else buildWall(cx, cz - R_SIZE/2, 0);
                if (!s) { const m = new THREE.Mesh(new THREE.BoxGeometry(R_SIZE, FULL_H, 1.5), wallMat); m.position.set(cx, FULL_H/2, cz + R_SIZE/2); scene.add(m); collidableWalls.push(new THREE.Box3().setFromObject(m)); } else buildWall(cx, cz + R_SIZE/2, 0);
                if (!e) { const m = new THREE.Mesh(new THREE.BoxGeometry(R_SIZE, FULL_H, 1.5), wallMat); m.position.set(cx + R_SIZE/2, FULL_H/2, cz); m.rotation.y = Math.PI/2; scene.add(m); collidableWalls.push(new THREE.Box3().setFromObject(m)); } else buildWall(cx + R_SIZE/2, cz, Math.PI/2);
                if (!w) { const m = new THREE.Mesh(new THREE.BoxGeometry(R_SIZE, FULL_H, 1.5), wallMat); m.position.set(cx - R_SIZE/2, FULL_H/2, cz); m.rotation.y = Math.PI/2; scene.add(m); collidableWalls.push(new THREE.Box3().setFromObject(m)); } else buildWall(cx - R_SIZE/2, cz, Math.PI/2);
                
                const f = new THREE.Mesh(new THREE.PlaneGeometry(R_SIZE, R_SIZE), new THREE.MeshStandardMaterial({ map: floorTex }));
                f.rotation.x = -Math.PI/2; f.position.set(cx, 0, cz); scene.add(f);
                const cp = new THREE.Mesh(new THREE.PlaneGeometry(R_SIZE, R_SIZE), ceilingMat);
                cp.rotation.x = Math.PI/2; cp.position.set(cx, FULL_H, cz); scene.add(cp);
                for(let i = -1; i <= 1; i++) {
                    const tube = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 10, 8), new THREE.MeshStandardMaterial({ color: 0x111111, emissive: 0xff4400, emissiveIntensity: 1 }));
                    tube.position.set(cx + (i * 6), FULL_H - 0.2, cz); tube.rotation.x = Math.PI / 2;
                    scene.add(tube); tubeMeshes.push(tube);
                }
            }
            for (let r = -2; r <= 2; r++) for (let c = -2; c <= 2; c++) createRoom(c * R_SIZE, r * R_SIZE, r > -2, r < 2, c < 2, c > -2);

            // Exit Door
            const doorFrame = new THREE.Group();
            const frameMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 2 });
            const leftBar = new THREE.Mesh(new THREE.BoxGeometry(0.2, 4.5, 0.2), frameMat); leftBar.position.set(-1.6, 2.25, 0);
            const rightBar = leftBar.clone(); rightBar.position.set(1.6, 2.25, 0);
            const topBar = new THREE.Mesh(new THREE.BoxGeometry(3.4, 0.2, 0.2), frameMat); topBar.position.set(0, 4.4, 0);
            const glow = new THREE.PointLight(0x00ff00, 5, 15); glow.position.y = 2;
            doorFrame.add(leftBar, rightBar, topBar, glow);
            const corners = [[-90, -90], [90, -90], [-90, 90], [90, 90]];
            const chosen = corners[Math.floor(Math.random() * corners.length)];
            doorFrame.position.set(chosen[0], 0, chosen[1]);
            doorFrame.visible = false;
            scene.add(doorFrame);
            exitDoor = doorFrame;

            // Artifacts
            const artColors = [0xff0000, 0x00ff00, 0x0000ff];
            artColors.forEach((color) => {
                const art = new THREE.Mesh(new THREE.IcosahedronGeometry(0.5, 0), new THREE.MeshStandardMaterial({ color: 0x000000, emissive: color, emissiveIntensity: 6 }));
                art.position.set((Math.random() - 0.5) * 160, 1.2, (Math.random() - 0.5) * 160);
                scene.add(art);
                artifacts.push(art);
            });

            // Entity
            entity = new THREE.Group();
            const eBody = new THREE.Mesh(new THREE.CapsuleGeometry(0.55, 2.2, 8, 12), new THREE.MeshStandardMaterial({ color: 0x000000 }));
            eBody.position.y = 2.5;
            const eye = new THREE.Mesh(new THREE.SphereGeometry(0.2), new THREE.MeshStandardMaterial({ color: 0x000000, emissive: 0x660000, emissiveIntensity: 5 }));
            const eL = eye.clone(); eL.position.set(-0.3, 3, 0.45);
            const eR = eye.clone(); eR.position.set(0.3, 3, 0.45);
            entity.add(eBody, eL, eR); scene.add(entity);

            player = new THREE.Group(); scene.add(player); player.add(camera);
            
            setupControls();
            renderer.compile(scene, camera); 
            resetGame();
            animate();
        }

        function toggleLight() {
            isLightOn = !isLightOn;
            leftLight.intensity = isLightOn ? 140 : 0;
            leftTip.material.color.setHex(isLightOn ? 0xffffff : 0x000000);
        }

        function shoot() {
            if(!gameActive || isJumpscaring || isEntityDead) return;
            raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
            const intersects = raycaster.intersectObject(entity, true);
            
            if (intersects.length > 0 && isLightOn) {
                isEntityDead = true;
                entityDeathTimer = 10.0;
                entity.traverse((child) => { if (child.material && child.material.emissive) child.material.emissiveIntensity = 0; });
            }

            muzzleLight.intensity = 20; muzzleFlashMesh.visible = true; muzzleFlashMesh.scale.set(1, 1, 1);
            const startPos = new THREE.Vector3(); muzzleAnchor.getWorldPosition(startPos);
            const targetPos = new THREE.Vector3(); camera.getWorldDirection(targetPos); 
            const camWorldPos = new THREE.Vector3(); camera.getWorldPosition(camWorldPos);
            targetPos.multiplyScalar(100).add(camWorldPos);
            const b = new THREE.Mesh(bulletGeo, bulletMat); b.position.copy(startPos); b.lookAt(targetPos); scene.add(b); bullets.push(b);
            recoilZ = 0.25; recoilRot = 0.4;
        }

        function handleCollision(obj, moveVec, isPlayer) {
            const size = isPlayer ? _pSize : _eSize;
            _v2.copy(obj.position).x += moveVec.x; _wallBox.setFromCenterAndSize(_v2, size);
            if (!collidableWalls.some(box => _wallBox.intersectsBox(box))) obj.position.x = _v2.x;
            _v2.copy(obj.position).z += moveVec.z; _wallBox.setFromCenterAndSize(_v2, size);
            if (!collidableWalls.some(box => _wallBox.intersectsBox(box))) obj.position.z = _v2.z;
        }

        function resetGame() {
            player.position.set(0, 2.2, 0); 
            entity.position.set(40, 0, 40);
            entity.rotation.set(0,0,0);
            entity.traverse((child) => { if (child.material && child.material.emissive) child.material.emissiveIntensity = 5; });
            isEntityDead = false; collectedCount = 0;
            document.getElementById('art-count').innerText = "0";
            document.getElementById('death-screen').style.display = 'none'; 
            document.getElementById('win-screen').style.display = 'none';
            isJumpscaring = false; jumpscareTimer = 0;
            camera.rotation.set(0,0,0);
            bullets.forEach(b => scene.remove(b)); bullets.length = 0;
            exitDoor.visible = false;
            artifacts.forEach(a => { a.visible = true; a.position.set((Math.random() - 0.5) * 160, 1.2, (Math.random() - 0.5) * 160); });
            gameActive = true; 
        }

        function setupControls() {
            // TOUCH CONTROLS
            window.addEventListener('touchstart', e => {
                if(isJumpscaring) return;
                for(let t of e.changedTouches) {
                    if(t.clientX < window.innerWidth/2) jId = t.identifier;
                    else if(t.target.className !== 'btn') { lId = t.identifier; lx = t.clientX; ly = t.clientY; }
                }
            }, {passive: false});
            window.addEventListener('touchmove', e => {
                if(isJumpscaring) return;
                for(let t of e.changedTouches) {
                    if(t.identifier === jId) {
                        const rect = document.getElementById('joystick-container').getBoundingClientRect();
                        const dx = Math.min(Math.max(t.clientX - (rect.left + 40), -35), 35), dy = Math.min(Math.max(t.clientY - (rect.top + 40), -35), 35);
                        document.getElementById('joystick-knob').style.transform = `translate(${dx}px, ${dy}px)`;
                        mS = dx/35; mF = -dy/35;
                    }
                    if(t.identifier === lId) { 
                        lT -= (t.clientX - lx) * 0.007; 
                        lP = Math.max(-1.4, Math.min(1.4, lP - (t.clientY - ly) * 0.007)); 
                        lx = t.clientX; ly = t.clientY; 
                    }
                }
            }, {passive: false});
            window.addEventListener('touchend', e => {
                for(let t of e.changedTouches) { 
                    if(t.identifier === jId) { jId = null; mF = mS = 0; document.getElementById('joystick-knob').style.transform = `translate(0,0)`; } 
                    if(t.identifier === lId) lId = null; 
                }
            });
            document.getElementById('flashlight-toggle').addEventListener('touchstart', (e) => { e.preventDefault(); toggleLight(); });
            document.getElementById('fire-btn').addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });

            // PC CONTROLS (Keyboard & Mouse)
            window.addEventListener('keydown', e => {
                const k = e.key.toLowerCase();
                if(k === 'w') keys.w = true; if(k === 's') keys.s = true;
                if(k === 'a') keys.a = true; if(k === 'd') keys.d = true;
                if(k === 'f') toggleLight();
            });
            window.addEventListener('keyup', e => {
                const k = e.key.toLowerCase();
                if(k === 'w') keys.w = false; if(k === 's') keys.s = false;
                if(k === 'a') keys.a = false; if(k === 'd') keys.d = false;
            });
            window.addEventListener('mousemove', e => {
                if(document.pointerLockElement === document.body) {
                    lT -= e.movementX * 0.002;
                    lP = Math.max(-1.4, Math.min(1.4, lP - e.movementY * 0.002));
                }
            });
            window.addEventListener('mousedown', e => {
                if(gameActive && document.pointerLockElement === document.body) {
                    if(e.button === 0) shoot();
                    if(e.button === 2) toggleLight();
                }
            });
            window.addEventListener('contextmenu', e => e.preventDefault());
        }

        function animate() {
            requestAnimationFrame(animate);
            if(!gameActive) return;

            // Handle PC Movement Logic
            if(jId === null) {
                mF = (keys.w ? 1 : 0) - (keys.s ? 1 : 0);
                mS = (keys.d ? 1 : 0) - (keys.a ? 1 : 0);
            }

            if (isJumpscaring) {
                jumpscareTimer += 0.016;
                camera.lookAt(entity.position.x, 3, entity.position.z);
                camera.position.x = (Math.random() - 0.5) * 0.5;
                camera.position.y = (Math.random() - 0.5) * 0.5;
                if (jumpscareTimer > 1.2) {
                    gameActive = false;
                    document.getElementById('death-screen').style.display = 'flex';
                    if(document.pointerLockElement) document.exitPointerLock();
                    setTimeout(resetGame, 2500);
                }
                renderer.render(scene, camera);
                return;
            }

            // Artifact Collection
            artifacts.forEach(art => {
                if(art.visible) {
                    art.rotation.y += 0.05; art.rotation.x += 0.02;
                    if(player.position.distanceTo(art.position) < 2) {
                        art.visible = false; collectedCount++;
                        document.getElementById('art-count').innerText = collectedCount;
                        showMessage(collectedCount === 3 ? "DOOR OPENED - FIND THE EXIT" : "ARTIFACT SECURED");
                        if(collectedCount === 3) exitDoor.visible = true;
                    }
                }
            });

            // Lighting effects
            tubeMeshes.forEach(t => { if (Math.random() > 0.995) { const on = t.material.emissiveIntensity > 0; t.material.emissiveIntensity = on ? 0 : 1; t.material.color.setHex(on ? 0x111111 : 0x221100); } });

            // Collision and Movement
            _playerBox.setFromCenterAndSize(player.position, _pSize);
            if (exitDoor.visible) {
                _exitBox.setFromCenterAndSize(exitDoor.position, new THREE.Vector3(3, 5, 3));
                if (_playerBox.intersectsBox(_exitBox)) {
                    gameActive = false;
                    document.getElementById('win-screen').style.display = 'flex';
                    if(document.pointerLockElement) document.exitPointerLock();
                    return;
                }
            }

            // Entity AI
            if (isEntityDead) {
                entityDeathTimer -= 0.016;
                let fallProgress = Math.min(1.0, (10.0 - entityDeathTimer) * 2);
                entity.rotation.x = fallProgress * (Math.PI / 2);
                if (entityDeathTimer <= 0) {
                    isEntityDead = false;
                    entity.rotation.x = 0;
                    entity.traverse((child) => { if (child.material && child.material.emissive) child.material.emissiveIntensity = 5; });
                    entity.position.set((Math.random() - 0.5) * 150, 0, (Math.random() - 0.5) * 150);
                }
            } else {
                _entityBox.setFromCenterAndSize(entity.position, _eSize);
                if (_playerBox.intersectsBox(_entityBox)) { isJumpscaring = true; isLightOn = true; leftLight.intensity = 200; return; }
                
                const dist = entity.position.distanceTo(player.position);
                const camMat = new THREE.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
                const inScreen = new THREE.Frustum().setFromProjectionMatrix(camMat).containsPoint(entity.position);
                _v1.subVectors(player.position, entity.position).normalize();
                raycaster.set(entity.position, _v1);
                const intersects = raycaster.intersectObjects(scene.children, true);
                let blocked = false;
                for(let i=0; i<intersects.length; i++) if(intersects[i].object.geometry.type === "BoxGeometry" && intersects[i].distance < dist) { blocked = true; break; }

                if (!isLightOn || !inScreen || blocked) {
                    handleCollision(entity, _v1.subVectors(player.position, entity.position).normalize().multiplyScalar(0.28), false);
                }
                entity.lookAt(player.position.x, 0, player.position.z);
            }

            // Final Camera/Weapon Transforms
            player.rotation.y = lT; camera.rotation.x = lP;
            const speedScale = Math.min(Math.sqrt(mF*mF + mS*mS), 1.0);
            bobTimer += (0.05 + (speedScale * 0.16)); 
            camera.position.y = Math.sin(bobTimer) * 0.08;
            camera.rotation.z = Math.cos(bobTimer) * 0.0125;
            leftHand.position.set(-0.5, -0.5 + Math.sin(bobTimer) * 0.02, -0.7);
            pistolGroup.position.set(0.5, -0.45 + Math.sin(bobTimer + 0.3) * 0.02, -0.7);
            recoilZ *= 0.85; recoilRot *= 0.85;
            pistolGroup.position.z += recoilZ; pistolGroup.rotation.x = recoilRot;
            
            if(muzzleLight.intensity > 0.1) muzzleLight.intensity *= 0.7; else muzzleLight.intensity = 0;
            if(muzzleFlashMesh.visible) { muzzleFlashMesh.scale.multiplyScalar(0.7); if(muzzleFlashMesh.scale.x < 0.1) muzzleFlashMesh.visible = false; }
            for (let i = bullets.length - 1; i >= 0; i--) { bullets[i].translateZ(1.5); if (bullets[i].position.distanceTo(player.position) > 100) { scene.remove(bullets[i]); bullets.splice(i, 1); } }
            
            _moveVec.copy(_v1.set(0,0,-1).applyQuaternion(player.quaternion)).multiplyScalar(mF * 0.16).add(_v2.set(1,0,0).applyQuaternion(player.quaternion).multiplyScalar(mS * 0.16));
            handleCollision(player, _moveVec, true);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

